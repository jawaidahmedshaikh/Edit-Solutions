package agent;

import edit.common.EDITDate;
import edit.common.vo.*;

import java.util.*;


/**
 * Created by IntelliJ IDEA.
 * User: gfrosti
 * Date: Feb 12, 2004
 * Time: 10:37:28 AM
 * To change this template use Options | File Templates.
 */
public class HierarchyReport
{
    private HierarchyReportVO hierarchyReportVO;
    private List rootReportEntries;
    private List hierarchyReportEntries;
    
    // TRUE if the report should render PlacedAgents with
    // a StopDate < today's the current date.
    private boolean includeExpiredAgents;
    
    /**
     * Denotes that this report is generated by a specified ContractCodeCt.
     */
    public static final int BY_CONTRACTCODECT = 0;
    
    /**
     * Stores the specified report type.
     */
    private int hierarchyReportType;
    
    /**
     * Stores the specified ContractCodeCT. If specified, it is assumed
     * that this report is of type:
     * @see BY_CONTRACTCODECT
     */
    private String contractCodeCT;

    /**
     * Stores the specified PlacedAgent. If specified, it is assumed
     * that this report is of type:
     * @see BY_PLACEDAGENT
     */    
    private PlacedAgent placedAgent;
    
    /**
     * Denotes that this report is generated by a specified PlacedAgent.
     */
    public static final int BY_PLACEDAGENT = 1;

    public HierarchyReport(boolean includeExpiredAgents, int hierarchyReportType, String contractCodeCT)
    {
        this.setIncludeExpiredAgents(includeExpiredAgents);
        
        this.setHierarchyReportType(hierarchyReportType);    

        rootReportEntries = new ArrayList();

        hierarchyReportEntries = new ArrayList();  
        
        this.hierarchyReportVO = new HierarchyReportVO();  
        
        this.setContractCode(contractCodeCT);
    }
    
    public HierarchyReport(boolean includeExpiredAgents, int hierarchyReportType, PlacedAgent placedAgent)
    {
        this(includeExpiredAgents, hierarchyReportType, placedAgent.getActivePlacedAgentCommissionProfile().getCommissionProfile().getContractCodeCT());
        
        this.setPlacedAgent(placedAgent);
    }    
    
    public String getContractCode()
    {
        return hierarchyReportVO.getContractCode();
    }
     //-- java.lang.String getContractCode() 

    public void setContractCode(String contractCode)
    {
        hierarchyReportVO.setContractCode(contractCode);
    }
     //-- void setContractCode(java.lang.String) 

    public void generateHierarchyReport()
    {
        if (getHierarchyReportType() == BY_CONTRACTCODECT)
        {
            PlacedAgent[] rootAgents = PlacedAgent.findBy_HierarchyLevel_and_ContractCodeCT(new Integer(0), getContractCode());

            for (int i = 0; i < rootAgents.length; i++)
            {
                generateHierarchyReportReportByPlacedAgent(rootAgents[i]);
            }
        }
        
        else if (getHierarchyReportType() == BY_PLACEDAGENT)
        { 
            generateHierarchyReportReportByPlacedAgent(getPlacedAgent());
        }
    }

    /**
     * Generates a report entry for the specified PlacedAgent.
     * @param placedAgent
     */
    private void generateHierarchyReportReportByPlacedAgent(PlacedAgent placedAgent)
    {   
        // PlacedAgent has a "getGroup" method, but we need to take advantage of Hibernate's "join fetch" for performance.        
        List group = null;

        group = new ArrayList(Arrays.asList(PlacedAgent.findBy_HierarchyLevelGTE_and_LeftBoundaryGTE_AND_RightBoundaryLTE(new Integer(placedAgent.getHierarchyLevel()), new Long(placedAgent.getLeftBoundary()), new Long(placedAgent.getRightBoundary()))));            
        
        HierarchyReportEntry rootEntry = generateHierarchyReportEntry(group);

        group.clear();

        if (rootEntry != null)
        {
            rootReportEntries.add(rootEntry);    
        }
    }

    private void validateHierarchies()
    {
        //        checkForOverlappingBoundaries();
        //        checkForSkippingHierarchies();  This isn't necessary - a child by definition is parentHierarchyLevel + 1.
    }

    private void checkForOverlappingBoundaries()
    {
        HierarchyReportEntry[] rootEntries = getRootHierarchyReportEntries();

        for (int i = 0; i < rootEntries.length; i++)
        {
            HierarchyReportEntry[] reportEntries = rootEntries[i].linearizeReportTree();

            Map entriesByLevel = groupEntriesByLevel(reportEntries);

            // Look for overlapping boundaries at each level
            Iterator keys = entriesByLevel.keySet().iterator();

            while (keys.hasNext())
            {
                Long key = (Long) keys.next();

                Stack entriesAtLevel = (Stack) entriesByLevel.get(key);

                flagInvalidBoundaries(entriesAtLevel);
            }
        }
    }

    private Map groupEntriesByLevel(HierarchyReportEntry[] reportEntries)
    {
        Map entriesByLevel = new HashMap();

        for (int j = 0; j < reportEntries.length; j++)
        {
            Long level = new Long(reportEntries[j].getVO().getPlacedAgentVO().getHierarchyLevel());

            Stack entriesAtLevel = null;

            if ((entriesAtLevel = (Stack) entriesByLevel.get(level)) == null)
            {
                entriesAtLevel = new Stack();

                entriesByLevel.put(level, entriesAtLevel);
            }

            entriesAtLevel.add(reportEntries[j]);
        }

        return entriesByLevel;
    }

    private void checkForSkippingHierarchies()
    {
        HierarchyReportEntry[] rootEntries = getRootHierarchyReportEntries();

        for (int i = 0; i < rootEntries.length; i++)
        {
            flagInvalidHierarchies(rootEntries[i]);
        }
    }

    private void flagInvalidHierarchies(HierarchyReportEntry parentEntry)
    {
        HierarchyReportEntry[] childEntries = parentEntry.getChildEntries();

        int parentLevel = parentEntry.getVO().getPlacedAgentVO().getHierarchyLevel();

        for (int i = 0; i < childEntries.length; i++)
        {
            int childLevel = childEntries[i].getVO().getPlacedAgentVO().getHierarchyLevel();

            childLevel--;

            if (childLevel != parentLevel) // parentLevel should ALWAYS be childLevel - 1
            {
                parentEntry.setHasError(true);

                childEntries[i].setHasError(true);
            }

            flagInvalidHierarchies(childEntries[i]);
        }
    }

    private void flagInvalidBoundaries(Stack entriesAtLevel)
    {
        if (entriesAtLevel.size() > 1) // An entry compared to itself if a trivial case and not necessary
        {
            HierarchyReportEntry entry = (HierarchyReportEntry) entriesAtLevel.pop();

            long targetLeftB = entry.getVO().getPlacedAgentVO().getLeftBoundary();

            long targetRightB = entry.getVO().getPlacedAgentVO().getRightBoundary();

            for (int i = 0; i < entriesAtLevel.size(); i++)
            {
                HierarchyReportEntry currentEntry = (HierarchyReportEntry) entriesAtLevel.get(i);

                long currentLeftB = currentEntry.getVO().getPlacedAgentVO().getLeftBoundary();

                long currentRightB = currentEntry.getVO().getPlacedAgentVO().getRightBoundary();

                if (withinRange(targetLeftB, currentLeftB, currentRightB))
                {
                    entry.setHasError(true);

                    currentEntry.setHasError(true);

                    break;
                }

                if (withinRange(targetRightB, currentLeftB, currentRightB))
                {
                    entry.setHasError(true);

                    currentEntry.setHasError(true);

                    break;
                }
            }

            flagInvalidBoundaries(entriesAtLevel);
        }
    }

    private boolean withinRange(long targetValue, long leftBoundary, long rightBoundary)
    {
        return ((targetValue > leftBoundary) && (targetValue < rightBoundary));
    }

    private HierarchyReportEntry[] getRootHierarchyReportEntries()
    {
        HierarchyReportEntry[] hierarchyReportEntries = (HierarchyReportEntry[]) rootReportEntries.toArray(new HierarchyReportEntry[rootReportEntries.size()]);

        return hierarchyReportEntries;
    }

    /**
     * Builds the HierarchyReport tree structure. The group List is assumed ordered by PlacedAgent.HierarchyLevel
     * ascending. The root PlacedAgent is assumed to be the 0th element.
     * @param group
     * @param group
     * @return
     */
    protected HierarchyReportEntry generateHierarchyReportEntry(List group)
    {
        HierarchyReportEntry parentHierarchyReportEntry = null;

        Map placedAgentCache = PlacedAgent.mapToMap(group);        
        
        Map hierarchyReportEntryCache = new HashMap();  

        int index = 0;
        
        int groupSize = group.size();

        for (int i = 0; i < groupSize; i++)
        {
            PlacedAgent currentPlacedAgent = (PlacedAgent) group.get(i);

            HierarchyReportEntry currentReportEntry = getHierarchyReportEntry(currentPlacedAgent, hierarchyReportEntryCache);

            // Capture the root HierarchyReportEntry to return.
            if (index == 0)
            {
                parentHierarchyReportEntry = currentReportEntry;
            }

            List childPlacedAgents = currentPlacedAgent.findClosestDescendantsFromMap(placedAgentCache);

            int childSize = childPlacedAgents.size();
            
            for (int j = 0; j < childSize; j++)
            {
                PlacedAgent currentChildPlacedAgent = (PlacedAgent) childPlacedAgents.get(j);

                HierarchyReportEntry currentChildReportEntry = getHierarchyReportEntry(currentChildPlacedAgent, hierarchyReportEntryCache);

                currentReportEntry.addChildEntry(currentChildReportEntry);
            }

            childPlacedAgents.clear();

            index++;
        }

        placedAgentCache.clear();

        hierarchyReportEntryCache.clear();

        return parentHierarchyReportEntry;
    }

    private HierarchyReportEntry getHierarchyReportEntry(PlacedAgent placedAgent, Map hierarchyReportEntryCache)
    {
        HierarchyReportEntry hierarchyReportEntry = (HierarchyReportEntry) hierarchyReportEntryCache.get(placedAgent);

        // Preserve a cache to establish parent/child relations between the HierarchyReportEntries.
        if (hierarchyReportEntry == null)
        {
            hierarchyReportEntry = new HierarchyReportEntry(placedAgent);

            hierarchyReportEntryCache.put(placedAgent, hierarchyReportEntry);
        }
        
        return hierarchyReportEntry;
    }

    public void compose()
    {
        HierarchyReportEntry[] reportEntries = getRootHierarchyReportEntries();

        if (reportEntries != null)
        {
            for (int i = 0; i < reportEntries.length; i++)
            {
                addHierarchyReportEntry(reportEntries[i]);
            }
        }
    }

    /**
     * Getter.
     * @return
     */
    public HierarchyReportEntry[] getHierarchyReportEntries()
    {
        return (HierarchyReportEntry[]) rootReportEntries.toArray(new HierarchyReportEntry[rootReportEntries.size()]);
    }

    private void addHierarchyReportEntry(HierarchyReportEntry reportEntry)
    {
        hierarchyReportEntries.add(reportEntry);
    }

    /**
     * Clears the elements of this report.
     */
    public void clear()
    {
        this.hierarchyReportEntries.clear();

        this.rootReportEntries.clear();
    }

    public boolean getIncludeExpiredAgents()
    {
        return includeExpiredAgents;
    }

    public void setIncludeExpiredAgents(boolean includeExpiredAgents)
    {
        this.includeExpiredAgents = includeExpiredAgents;
    }

    public int getHierarchyReportType()
    {
        return hierarchyReportType;
    }

    public void setHierarchyReportType(int hierarchyReportType)
    {
        this.hierarchyReportType = hierarchyReportType;
    }

    public PlacedAgent getPlacedAgent()
    {
        return placedAgent;
    }

    public void setPlacedAgent(PlacedAgent placedAgent)
    {
        this.placedAgent = placedAgent;
    }
}
