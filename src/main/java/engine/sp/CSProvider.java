/*
 * CSProvider.java       Version 1.0   03/21/2003
 *
 * Copyright (c) 2003 Systems Engineering Group, LLC. All Rights Reserved
 *
 *
 * This program is the confidential and proprietary information of
 * Systems Engineering Group, LLC anbd may not be copied in whole or  in
 * part without the written permission of Systems engineering group, LLC.
 */
package engine.sp;

import engine.ProductStructure;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;


public class CSProvider
{
    /**
     * The set of compiled scripts identified by the ScriptPK.
     */
    private TreeMap<String, List<CompiledScript>> compiledScripts = new TreeMap<String, List<CompiledScript>>();

    /**
     * Threads need to be synchronized since CompiledScripts can never be shared.
     */
    private static final Object MONITOR = new Object();

    public CSProvider()
    {
        super();
    }

    /**
     * Only the very first script has to be added. From that point on, additional
     * compiled scripts (for the pool) will be auto-generated by cloning. Any additional
     * call to this method for a CompiledScript that already exists will be ignored.
     * The script that is added is set to be "in-use" and it will never change since
     * it is this first script which will serve as the template for every other
     * borrowed script.
     * @param scriptPK
     * @param script
     * @param labels
     */
    public void addCompiledScript(Long scriptPK, ProductRuleProcessor pr, List<Inst> script, TreeMap<String, String> labels)
    {
        synchronized (MONITOR)
        {
            String compiledScriptKey = getCompiledScriptKey(scriptPK, pr);

            if (!compiledScriptExists(compiledScriptKey))
            {
                CompiledScript compiledScript = new CompiledScript(compiledScriptKey, script, labels);

                compiledScript.setInUse(true);

                List<CompiledScript> compiledScriptsByKey = new ArrayList<CompiledScript>();

                compiledScriptsByKey.add(compiledScript);

                getCompiledScripts().put(compiledScriptKey, compiledScriptsByKey);
            }
        }
    }

    /**
     * Checks the current set of CompiledScript to see if one is available.
     * If [not], then it clones the target script, adds it to the pool
     * of CompiledScripts, and returns it. The pool is allowed to grow
     * indefinitely in the belief that the pooling demand will be very
     * manageable.
     * @param scriptPK
     * @return
     */
    protected CompiledScript borrowCompiledScript(Long scriptPK, ProductRuleProcessor pr)
    {
        CompiledScript targetCompiledScript = null;

        synchronized (MONITOR)
        {
            List<CompiledScript> compiledScriptsByKey = getCompiledScriptsByKey(scriptPK, pr);

            // Look for an unused script
            for (CompiledScript currentCompiledScript: compiledScriptsByKey)
            {
                if (!currentCompiledScript.isInUse())
                {
                    targetCompiledScript = currentCompiledScript;

                    targetCompiledScript.setInUse(true);

                    break;
                }
            }

            // There are no unused scripts. Make a new CompiledScript instance,
            // put it into the List (marked as being in use) and return it for use.
            // If there aren't any CompiledScripts at all, then none have been
            // added to the pool as of yet.
            if ((targetCompiledScript == null) && (!compiledScriptsByKey.isEmpty()))
            {
                // We don't care which CompiledScript (by scriptPK), the 0th one is fine.
                CompiledScript compiledScriptToClone = compiledScriptsByKey.get(0);

                targetCompiledScript = compiledScriptToClone.clone();

                targetCompiledScript.setInUse(true);

                compiledScriptsByKey.add(targetCompiledScript);
            }

            return targetCompiledScript;
        }
    }

    /**
     * The CompiledScript was originall retrieved "by reference". We need
     * only set its in-use flag to false.
     * @param cs
     */
    public void returnCompiledScript(CompiledScript cs)
    {
        synchronized (MONITOR)
        {
            cs.setInUse(false);
        }
    }

    /**
     * Getter.
     * @see #compiledScripts
     * @return
     */
    private Map<String, List<CompiledScript>> getCompiledScripts()
    {
        return compiledScripts;
    }

    /**
     * True if the collection of compiled scripts contains the specified script (by scriptPK).
     * @param compiledScriptKey
     * @return
     */
    public boolean compiledScriptExists(String compiledScriptKey)
    {
        return !getCompiledScripts().get(compiledScriptKey).isEmpty();
    }

    /**
     * Clears [all] CompiledScript from its collections.
     */
    public void clear()
    {
        java.util.Set<String> keys = getCompiledScripts().keySet();

        for (String key: keys)
        {
            List<CompiledScript> currentCompiledScripts = getCompiledScripts().get(key);

            currentCompiledScripts.clear();
        }

        getCompiledScripts().clear();
    }

    /**
     * Looks to find the specified List of CompiledScripts by PK. If
     * there is no such List, then an empty List is created and added
     * to the cached CompiledScripts (by PK).
     * @param scriptPK
     * @return
     */
    private List<CompiledScript> getCompiledScriptsByKey(Long scriptPK, ProductRuleProcessor pr)
    {
        String compiledScriptKey = getCompiledScriptKey(scriptPK, pr);

        List<CompiledScript> compiledScriptsByKey = getCompiledScripts().get(compiledScriptKey);

        if (compiledScriptsByKey == null)
        {
            compiledScriptsByKey = new ArrayList<CompiledScript>();

            getCompiledScripts().put(compiledScriptKey, compiledScriptsByKey);
        }

        return compiledScriptsByKey;
    }

    /**
     * Generates a simple unique identifier for a Compile Script.
     * @param scriptPK
     * @param pr
     * @return
     */
    private String getCompiledScriptKey(Long scriptPK, ProductRuleProcessor pr)
    {
        return scriptPK.longValue() + ":" + pr.getProductStructurePK();
    }
}
